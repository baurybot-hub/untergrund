<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>UnterGrund ‚Äì Explorer</title>
  <style>
body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  color: #e5e7eb;
  margin: 0;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.app {
  width: 100%;
  max-width: 480px;
  margin: 0 auto;
  padding: 16px 16px 24px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  flex: 1;
}

footer {
  font-size: 0.7rem;
  color: #6b7280;
  text-align: center;
  margin: 24px 0 8px;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 14px;
  border-radius: 999px;
  background: rgba(15, 23, 42, 0.9);
  border: 1px solid rgba(55, 65, 81, 0.8);
  backdrop-filter: blur(10px);
}

.logo-text {
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  font-size: 0.8rem;
}
.pill-btn {
  border-radius: 999px;
  border: none;
  padding: 8px 14px;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: #22c55e;
  color: #022c22;
  transition: all 0.2s ease;
}
.pill-btn:hover {
  background: #16a34a;
  transform: translateY(-1px);
}
.pill-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

.card {
  background: rgba(15, 23, 42, 0.98);
  border-radius: 22px;
  padding: 22px 18px 18px;
  box-shadow: 0 30px 80px rgba(0,0,0,0.75);
  border: 1px solid #1f2937;
}
.card-title {
  font-size: 1.2rem;
  font-weight: 600;
  margin-bottom: 2px;
}
.card-sub {
  font-size: 0.82rem;
  color: #9ca3af;
  margin-top: 0;
  margin-bottom: 12px;
}
.artist-name {
  font-size: 1.25rem;
  font-weight: 600;
  margin-bottom: 10px;
}
.embed-wrapper {
  border-radius: 16px;
  overflow: hidden;
  margin-bottom: 10px;
  background: #020617;
}
iframe {
  border: none;
  width: 100%;
  height: 152px;
}
.status-text {
  font-size: 0.8rem;
  color: #9ca3af;
  min-height: 1.2em;
  margin-bottom: 8px;
}

/* Focus Buttons */
.focus-buttons {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}
.focus-btn {
  flex: 1;
  border-radius: 12px;
  border: 1px solid #374151;
  padding: 10px 12px;
  font-size: 0.8rem;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  background: rgba(34, 197, 94, 0.1);
  color: #4ade80;
  transition: all 0.2s ease;
}
.focus-btn:hover {
  background: rgba(34, 197, 94, 0.2);
  border-color: #22c55e;
  transform: translateY(-1px);
}
.focus-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}
.focus-btn.maxed {
  background: rgba(100, 116, 139, 0.1);
  color: #64748b;
  border-color: #334155;
}

/* Focus Info */
.focus-info {
  font-size: 0.75rem;
  color: #6b7280;
  text-align: center;
  margin-bottom: 8px;
  min-height: 1em;
}

/* Toast */
.toast {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%) translateY(100px);
  background: rgba(34, 197, 94, 0.95);
  color: #022c22;
  padding: 12px 20px;
  border-radius: 999px;
  font-size: 0.85rem;
  font-weight: 600;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  z-index: 100;
  opacity: 0;
  transition: all 0.3s ease;
  pointer-events: none;
}
.toast.show {
  transform: translateX(-50%) translateY(0);
  opacity: 1;
}

.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.9);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 50;
}
.modal {
  background: #020617;
  border-radius: 18px;
  border: 1px solid #1f2937;
  padding: 20px 18px 16px;
  width: 100%;
  max-width: 420px;
  box-shadow: 0 24px 70px rgba(0,0,0,0.8);
}
.modal h2 {
  font-size: 1.1rem;
  margin: 0 0 6px;
}
.modal p {
  font-size: 0.8rem;
  color: #9ca3af;
  margin: 0 0 12px;
}
label {
  font-size: 0.78rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #6b7280;
  display: block;
  margin-bottom: 4px;
}
input {
  width: 100%;
  margin-bottom: 12px;
  padding: 9px 11px;
  border-radius: 10px;
  border: 1px solid #374151;
  background: #020617;
  color: #e5e7eb;
  font-size: 0.9rem;
}
input:focus {
  outline: none;
  border-color: #22c55e;
  box-shadow: 0 0 0 1px #22c55e33;
}
.modal-actions {
  display: flex;
  gap: 10px;
  margin-top: 4px;
}
.modal-btn {
  flex: 1;
  border-radius: 999px;
  border: none;
  padding: 9px 12px;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
}
.modal-btn.cancel {
  background: #111827;
  color: #e5e7eb;
  border: 1px solid #374151;
}
.modal-btn.submit {
  background: #22c55e;
  color: #022c22;
}
.modal-status {
  font-size: 0.78rem;
  margin-top: 6px;
  min-height: 1.2em;
}
.modal-status.err { color: #f97373; }
.modal-status.ok { color: #4ade80; }

@media (min-height: 800px) {
  .app { gap: 20px; }
}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="logo-text">UnterGrund</div>
      <button class="pill-btn" onclick="openSubmit()">
        ‚ûï Artist vorschlagen
      </button>
    </header>

    <div class="card">
      <div class="card-title">UnterGrund Explorer</div>
      <p class="card-sub">Deutsche Artists entdecken, die noch unter dem Radar fliegen. Pushe deine Favoriten nach oben!</p>

      <div id="artist-name" class="artist-name">Lade Artist‚Ä¶</div>
      <div id="embed-wrapper" class="embed-wrapper"></div>
      
      <!-- Focus Buttons -->
      <div class="focus-buttons">
        <button id="btn-play" class="focus-btn" onclick="triggerFocusPlay()" disabled>
          üéµ Play on Spotify
        </button>
        <button id="btn-follow" class="focus-btn" onclick="triggerFocusFollow()" disabled>
          üíö Follow
        </button>
      </div>

      <div id="focus-info" class="focus-info"></div>
      <div id="status-text" class="status-text"></div>

      <button class="pill-btn" style="width:100%;justify-content:center;margin-top:8px;" onclick="loadNextArtist()">
        üîÅ N√§chster Artist
      </button>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast" class="toast"></div>
  
  <div id="submit-modal" class="modal-backdrop">
    <div class="modal">
      <h2>Artist vorschlagen</h2>
      <p>Trage einen deutschen Artist ein, den man entdecken sollte.</p>
      <p style="font-size:0.78rem;color:#9ca3af;margin-top:4px;">
        Du hilfst, echte Untergrund‚ÄëActs sichtbar zu machen.
      </p>

      <label for="artist-input">Artist‚ÄëName</label>
      <input id="artist-input" placeholder="z.B. Doktor Eule" />

      <label for="spotify-input">Spotify‚ÄëArtist‚ÄëURL</label>
      <input id="spotify-input" placeholder="https://open.spotify.com/artist/‚Ä¶" />

      <div class="modal-actions">
        <button class="modal-btn cancel" onclick="closeSubmit()">Abbrechen</button>
        <button class="modal-btn submit" onclick="submitArtist()">Speichern</button>
      </div>

      <div id="submit-status" class="modal-status"></div>
    </div>
  </div>

  <div id="legal-modal-backdrop" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(15,23,42,0.9);z-index:80;">
    <div id="legal-modal" style="width:100%;max-width:480px;max-height:80vh;overflow-y:auto;background:#020617;border-radius:18px;border:1px solid #1f2937;padding:18px 16px 14px;box-shadow:0 24px 70px rgba(0,0,0,0.85);font-size:0.78rem;color:#e5e7eb;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h2 id="legal-modal-title" style="font-size:0.9rem;margin:0;">Rechtliches</h2>
        <button onclick="closeLegal()" style="background:none;border:none;color:#9ca3af;font-size:1rem;cursor:pointer;">&times;</button>
      </div>
      <div id="legal-modal-content" style="color:#9ca3af;line-height:1.4;"></div>
    </div>
  </div>

  <footer>
    <button onclick="openLegal('impressum')" style="background:none;border:none;color:#9ca3af;text-decoration:underline;cursor:pointer;margin-right:12px;">
      Impressum
    </button>
    <button onclick="openLegal('datenschutz')" style="background:none;border:none;color:#9ca3af;text-decoration:underline;cursor:pointer;">
      Datenschutzhinweise
    </button>
  </footer>
  
  <script>
    const SUPABASE_URL = "https://tyflhzwrwzfakwedipig.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_OkJhaPak_fd0nNg1vxRLPQ_gOiaI6Tb";
    const ARTISTS_TABLE = "artists";

    const MAX_PLAY_POINTS = 3;
    const MAX_FOLLOW_POINTS = 1;

    let allArtists = [];
    let seenArtistIds = new Set();
    let loading = false;
    let currentArtist = null;
    let currentSpotifyEmbedId = null;

    // Client ID
    function getClientId() {
      const KEY = "ug_client_id";
      let id = localStorage.getItem(KEY);
      if (!id) {
        id = "cli_" + Math.random().toString(36).slice(2) + Date.now().toString(36);
        localStorage.setItem(KEY, id);
      }
      return id;
    }

    // Toast
    function showToast(message) {
      const toast = document.getElementById("toast");
      toast.textContent = message;
      toast.classList.add("show");
      setTimeout(() => {
        toast.classList.remove("show");
      }, 2500);
    }

    // Focus Event API
    async function addFocusEvent(artist, type) {
      const clientId = getClientId();

      // 1) focus_events f√ºr diesen Artist & Client holen
      const resGet = await fetch(
        `${SUPABASE_URL}/rest/v1/focus_events?artist_id=eq.${artist.id}&client_id=eq.${encodeURIComponent(clientId)}&select=*`,
        {
          headers: {
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`
          }
        }
      );

      if (!resGet.ok) {
        console.error("focus_events GET Fehler", await resGet.text());
        return false;
      }

      let rows = await resGet.json();
      let row = rows[0];

      // 2) Falls es noch keinen Eintrag gibt ‚Üí anlegen
      if (!row) {
        const initRes = await fetch(
          `${SUPABASE_URL}/rest/v1/focus_events`,
          {
            method: "POST",
            headers: {
              "apikey": SUPABASE_ANON_KEY,
              "Authorization": `Bearer ${SUPABASE_ANON_KEY}`,
              "Content-Type": "application/json",
              "Prefer": "return=representation"
            },
            body: JSON.stringify({
              artist_id: artist.id,
              client_id: clientId
            })
          }
        );
        if (!initRes.ok) {
          console.error("focus_events INIT Fehler", await initRes.text());
          return false;
        }
        const created = await initRes.json();
        row = created[0];
      }

      // 3) pr√ºfen, ob f√ºr diesen Typ noch Punkte √ºbrig sind
      const updateEvent = {};
      if (type === "play") {
        if (row.play_count >= MAX_PLAY_POINTS) return false;
        updateEvent.play_count = row.play_count + 1;
      } else if (type === "follow") {
        if (row.follow_used) return false;
        updateEvent.follow_used = true;
      } else {
        return false;
      }

      // 4) focus_events aktualisieren
      const resUpdateEvent = await fetch(
        `${SUPABASE_URL}/rest/v1/focus_events?id=eq.${row.id}`,
        {
          method: "PATCH",
          headers: {
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`,
            "Content-Type": "application/json",
            "Prefer": "return=minimal"
          },
          body: JSON.stringify(updateEvent)
        }
      );

      if (!resUpdateEvent.ok) {
        console.error("focus_events UPDATE Fehler", await resUpdateEvent.text());
        return false;
      }

      // 5) Focus-Score des Artists global +1
      const newScore = (artist.focus_score || 0) + 1;

      const resUpdateArtist = await fetch(
        `${SUPABASE_URL}/rest/v1/${ARTISTS_TABLE}?id=eq.${artist.id}`,
        {
          method: "PATCH",
          headers: {
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`,
            "Content-Type": "application/json",
            "Prefer": "return=minimal"
          },
          body: JSON.stringify({
            focus_score: newScore
          })
        }
      );

      if (!resUpdateArtist.ok) {
        console.error("artists focus_score UPDATE Fehler", await resUpdateArtist.text());
        return false;
      }

      // 6) Artist-Objekt im Frontend updaten
      artist.focus_score = newScore;
      return true;
    }

    // Focus-Limits laden
    async function loadFocusLimits(artist) {
      const clientId = getClientId();
      const res = await fetch(
        `${SUPABASE_URL}/rest/v1/focus_events?artist_id=eq.${artist.id}&client_id=eq.${encodeURIComponent(clientId)}&select=*`,
        {
          headers: {
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`
          }
        }
      );

      if (!res.ok) return { play_count: 0, follow_used: false };

      const rows = await res.json();
      if (rows.length === 0) return { play_count: 0, follow_used: false };

      return rows[0];
    }

    // UI aktualisieren
    async function updateFocusUI() {
      if (!currentArtist) return;

      const limits = await loadFocusLimits(currentArtist);
      const playBtn = document.getElementById("btn-play");
      const followBtn = document.getElementById("btn-follow");
      const focusInfo = document.getElementById("focus-info");

      const playLeft = MAX_PLAY_POINTS - limits.play_count;
      const followLeft = limits.follow_used ? 0 : MAX_FOLLOW_POINTS;

      // Play Button
      if (playLeft > 0) {
        playBtn.disabled = false;
        playBtn.classList.remove("maxed");
      } else {
        playBtn.disabled = true;
        playBtn.classList.add("maxed");
      }

      // Follow Button
      if (followLeft > 0) {
        followBtn.disabled = false;
        followBtn.classList.remove("maxed");
      } else {
        followBtn.disabled = true;
        followBtn.classList.add("maxed");
      }

      // Info Text
      const total = playLeft + followLeft;
      if (total > 0) {
        focusInfo.textContent = `Du kannst ${currentArtist.name || "diesen Artist"} noch ${total}√ó pushen`;
      } else {
        focusInfo.textContent = `Du hast ${currentArtist.name || "diesen Artist"} maximal gepusht! üî•`;
      }
    }

    // Focus Trigger: Play
    async function triggerFocusPlay() {
      if (!currentArtist) return;

      const success = await addFocusEvent(currentArtist, "play");

      if (success) {
        showToast(`Focus +1 ‚Äì Du pushst ${currentArtist.name || "den Artist"}!`);
        await updateFocusUI();
        
        // Zu Spotify √∂ffnen
        const spotifyUrl = normalizeSpotifyArtistUrl(currentArtist.spotify_url);
        if (spotifyUrl) {
          window.open(spotifyUrl, "_blank");
        }
      } else {
        showToast("Limit erreicht ‚Äì du hast diesen Artist schon genug gepusht!");
      }
    }

    // Focus Trigger: Follow
    async function triggerFocusFollow() {
      if (!currentArtist) return;

      const success = await addFocusEvent(currentArtist, "follow");

      if (success) {
        showToast(`Focus +1 ‚Äì Du folgst ${currentArtist.name || "dem Artist"}!`);
        await updateFocusUI();
        
        // Zu Spotify Profil √∂ffnen
        const spotifyUrl = normalizeSpotifyArtistUrl(currentArtist.spotify_url);
        if (spotifyUrl) {
          window.open(spotifyUrl, "_blank");
        }
      } else {
        showToast("Du folgst diesem Artist bereits!");
      }
    }

    // Spotify iFrame API (Play-Event im Embed tracken)
    window.addEventListener("message", async (event) => {
      if (event.origin !== "https://open.spotify.com") return;

      try {
        const data = JSON.parse(event.data);
        
        // Wenn Play gedr√ºckt wird im Embed
        if (data.type === "playback_update" && data.isPaused === false && currentArtist && currentSpotifyEmbedId) {
          const success = await addFocusEvent(currentArtist, "play");
          if (success) {
            showToast(`Focus +1 ‚Äì ${currentArtist.name || "Artist"} spielt! üéµ`);
            await updateFocusUI();
          }
        }
      } catch (err) {
        // Ignore parse errors
      }
    });

    // zentrale Normalisierung
    function normalizeSpotifyArtistUrl(url) {
      if (!url) return null;
      let clean = url.split("?")[0].trim();
      clean = clean.replace("open.spotify.com/intl-de/", "open.spotify.com/");
      if (clean.endsWith("/")) clean = clean.slice(0, -1);
      return clean;
    }

    function spotifyUrlToEmbed(url) {
      const clean = normalizeSpotifyArtistUrl(url);
      if (!clean) return null;
      if (!clean.includes("open.spotify.com/artist/")) return null;
      const embedUrl = clean.replace("open.spotify.com/artist/", "open.spotify.com/embed/artist/");
      
      // Extract artist ID for iframe API
      const match = clean.match(/artist\/([a-zA-Z0-9]+)/);
      currentSpotifyEmbedId = match ? match[1] : null;
      
      return embedUrl;
    }

    function isValidSpotifyArtistUrl(url) {
      if (!url) return false;
      const clean = normalizeSpotifyArtistUrl(url);
      return clean.startsWith("https://open.spotify.com/artist/");
    }

    async function loadAllArtists() {
      const res = await fetch(
        `${SUPABASE_URL}/rest/v1/${ARTISTS_TABLE}?select=*`,
        {
          headers: {
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`
          }
        }
      );

      if (!res.ok) {
        const txt = await res.text();
        console.error("Artists Load Fehler:", res.status, txt);
        throw new Error("Supabase Load Fehler: " + res.status);
      }

      allArtists = await res.json();
    }

    function pickRandomUnseenArtist() {
      const unseen = allArtists.filter(a => !seenArtistIds.has(a.id));
      if (unseen.length === 0) return null;
      const idx = Math.floor(Math.random() * unseen.length);
      return unseen[idx];
    }

    async function loadNextArtist() {
      if (loading) return;
      loading = true;

      const nameEl = document.getElementById("artist-name");
      const statusEl = document.getElementById("status-text");
      const embedWrapper = document.getElementById("embed-wrapper");
      const playBtn = document.getElementById("btn-play");
      const followBtn = document.getElementById("btn-follow");
      const focusInfo = document.getElementById("focus-info");

      nameEl.textContent = "Suche n√§chsten Artist‚Ä¶";
      statusEl.textContent = "";
      embedWrapper.innerHTML = "";
      playBtn.disabled = true;
      followBtn.disabled = true;
      focusInfo.textContent = "";
      currentArtist = null;
      currentSpotifyEmbedId = null;

      try {
        if (!allArtists || allArtists.length === 0) {
          await loadAllArtists();
        }

        let artist = pickRandomUnseenArtist();

        if (!artist) {
          await loadAllArtists();
          seenArtistIds = new Set();
          artist = pickRandomUnseenArtist();
        }

        if (!artist) {
          nameEl.textContent = "Noch keine Artists gespeichert.";
          return;
        }

        seenArtistIds.add(artist.id);
        currentArtist = artist;

        nameEl.textContent = artist.name || "";
        statusEl.textContent = "Pushe diesen Artist mit den Buttons oben! Jeder Klick z√§hlt.";

        const embedUrl = spotifyUrlToEmbed(artist.spotify_url);
        if (embedUrl) {
          embedWrapper.innerHTML = `<iframe src="${embedUrl}" allow="encrypted-media"></iframe>`;
        } else {
          embedWrapper.innerHTML = `<div style="font-size:0.85rem;color:#f97373;padding:12px;">
            Kein g√ºltiger Spotify‚ÄëLink gespeichert.
          </div>`;
        }

        // Focus UI aktualisieren
        await updateFocusUI();

      } catch (err) {
        console.error("loadNextArtist Fehler:", err);
        nameEl.textContent = "Fehler beim Laden.";
        statusEl.textContent = "Bitte sp√§ter erneut versuchen.";
      } finally {
        loading = false;
      }
    }

    function openSubmit() {
      document.getElementById("submit-modal").style.display = "flex";
      document.getElementById("submit-status").textContent = "";
      document.getElementById("artist-input").focus();
    }

    function closeSubmit() {
      document.getElementById("submit-modal").style.display = "none";
    }

    async function submitArtist() {
      const nameInput = document.getElementById("artist-input");
      const spotifyInput = document.getElementById("spotify-input");
      const statusEl = document.getElementById("submit-status");

      const manualName = nameInput.value.trim();
      const rawUrl = spotifyInput.value.trim();

      if (!manualName) {
        statusEl.textContent = "Bitte den Artist‚ÄëNamen eingeben.";
        statusEl.className = "modal-status err";
        return;
      }

      if (!rawUrl) {
        statusEl.textContent = "Bitte eine Spotify‚ÄëArtist‚ÄëURL eingeben.";
        statusEl.className = "modal-status err";
        return;
      }

      if (!isValidSpotifyArtistUrl(rawUrl)) {
        statusEl.textContent = "Bitte einen g√ºltigen Spotify‚ÄëArtist‚ÄëLink eingeben (https://open.spotify.com/artist/‚Ä¶).";
        statusEl.className = "modal-status err";
        return;
      }

      const cleanUrl = normalizeSpotifyArtistUrl(rawUrl);

      statusEl.textContent = "Pr√ºfe, ob der Artist schon existiert‚Ä¶";
      statusEl.className = "modal-status";

      try {
        const checkRes = await fetch(
          `${SUPABASE_URL}/rest/v1/${ARTISTS_TABLE}?spotify_url=eq.${encodeURIComponent(cleanUrl)}&select=id`,
          {
            headers: {
              "apikey": SUPABASE_ANON_KEY,
              "Authorization": `Bearer ${SUPABASE_ANON_KEY}`
            }
          }
        );

        if (!checkRes.ok) {
          const txt = await checkRes.text();
          console.error("Check Fehler:", checkRes.status, txt);
          throw new Error("Supabase Check Fehler: " + checkRes.status);
        }

        const existing = await checkRes.json();

        if (existing.length > 0) {
          statusEl.textContent = "Dieser Artist ist schon im UnterGrund gespeichert.";
          statusEl.className = "modal-status err";
          return;
        }

        statusEl.textContent = "Speichere Artist‚Ä¶";

        const res = await fetch(`${SUPABASE_URL}/rest/v1/${ARTISTS_TABLE}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`,
            "Prefer": "return=minimal"
          },
          body: JSON.stringify({
            name: manualName,
            spotify_url: cleanUrl
          })
        });

        if (!res.ok) {
          const txt = await res.text();
          console.error("Insert Fehler:", res.status, txt);
          if (res.status === 409) {
            statusEl.textContent = "Dieser Artist existiert bereits (DB‚ÄëConstraint).";
            statusEl.className = "modal-status err";
            return;
          }
          throw new Error("Supabase Insert Fehler: " + res.status);
        }

        nameInput.value = "";
        spotifyInput.value = "";
        statusEl.textContent = "‚úÖ Artist gespeichert! Er erscheint im Explorer.";
        statusEl.className = "modal-status ok";

        await loadAllArtists();
      } catch (err) {
        console.error("submitArtist Fehler:", err);
        statusEl.textContent = "‚ùå Fehler: " + (err?.message || "Unbekannter Fehler");
        statusEl.className = "modal-status err";
      }
    }

    const LEGAL_TEXT = {
      impressum: `
        <p>Verantwortlich f√ºr den Inhalt dieser Seite:</p>
        <p>
          [Dein Vor- und Nachname]<br>
          [Stra√üe, Hausnummer]<br>
          [PLZ, Ort]<br>
          Deutschland
        </p>
        <p>E-Mail: [deine@email.de]</p>
      `,
      datenschutz: `
        <p>Diese Seite wird √ºber GitHub Pages und Supabase bereitgestellt.
        Beim Aufruf werden technisch notwendige Daten (z.B. IP-Adresse,
        Datum und Uhrzeit des Abrufs, aufgerufene URL, User-Agent) verarbeitet.</p>

        <p>Beim Vorschlagen von Artists werden die eingegebenen Daten
        (Artist-Name, Spotify-URL) in einer Supabase-Datenbank gespeichert und
        im ‚ÄûUnterGrund Explorer" angezeigt. Auf Anfrage per E-Mail werden Eintr√§ge
        gel√∂scht und von weiteren Vorschl√§gen ausgeschlossen.</p>

        <p>Auf dieser Seite sind Spotify-Player eingebunden. Anbieter ist Spotify AB.
        Beim Laden eines Spotify-Embeds kann Spotify personenbezogene Daten
        verarbeiten. Weitere Informationen enth√§lt die Datenschutzerkl√§rung von Spotify.</p>
        
        <p>Diese Seite nutzt localStorage zur Speicherung einer anonymen Client-ID,
        um Focus-Events pro Nutzer zu begrenzen. Diese ID verl√§sst Ihren Browser nicht
        und dient ausschlie√ülich der technischen Limitierung.</p>
      `
    };

    function openLegal(type) {
      const backdrop = document.getElementById("legal-modal-backdrop");
      const titleEl = document.getElementById("legal-modal-title");
      const contentEl = document.getElementById("legal-modal-content");

      if (type === "impressum") {
        titleEl.textContent = "Impressum";
        contentEl.innerHTML = LEGAL_TEXT.impressum;
      } else {
        titleEl.textContent = "Datenschutzhinweise";
        contentEl.innerHTML = LEGAL_TEXT.datenschutz;
      }

      backdrop.style.display = "flex";
    }

    function closeLegal() {
      document.getElementById("legal-modal-backdrop").style.display = "none";
    }
    
    window.addEventListener("load", () => {
      loadNextArtist();
    });
  </script>
</body>
</html>
