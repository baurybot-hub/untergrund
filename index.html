<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>UnterGrund ‚Äì Explorer</title>
  <style>
body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
  color: #e5e7eb;
  margin: 0;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.app {
  width: 100%;
  max-width: 480px;
  margin: 0 auto;
  padding: 16px 16px 24px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  flex: 1;
}

footer {
  font-size: 0.7rem;
  color: #6b7280;
  text-align: center;
  margin: 24px 0 8px;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 14px;
  border-radius: 999px;
  background: rgba(15, 23, 42, 0.9);
  border: 1px solid rgba(55, 65, 81, 0.8);
  backdrop-filter: blur(10px);
}

.logo-text {
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  font-size: 0.8rem;
}
.pill-btn {
  border-radius: 999px;
  border: none;
  padding: 8px 14px;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: #22c55e;
  color: #022c22;
}

/* Karte */
.card {
  background: rgba(15, 23, 42, 0.98);
  border-radius: 22px;
  padding: 22px 18px 18px;
  box-shadow: 0 30px 80px rgba(0,0,0,0.75);
  border: 1px solid #1f2937;
}
.card-title {
  font-size: 1.2rem;
  font-weight: 600;
}
.card-sub {
  font-size: 0.82rem;
  color: #9ca3af;
  margin-top: 4px;
  margin-bottom: 12px;
}
.artist-name {
  font-size: 1.25rem;
  font-weight: 600;
  margin-bottom: 10px;
}
.embed-wrapper {
  border-radius: 16px;
  overflow: hidden;
  margin-bottom: 10px;
  background: #020617;
}
iframe {
  border: none;
  width: 100%;
  height: 152px;
}
.status-text {
  font-size: 0.8rem;
  color: #9ca3af;
  min-height: 1.2em;
  margin-bottom: 8px;
}

/* Focus: Buttons + Info */
.focus-buttons {
  display: flex;
  gap: 8px;
  margin-bottom: 6px;
}
.focus-btn {
  flex: 1;
  border-radius: 999px;
  border: 1px solid #374151;
  padding: 8px 10px;
  font-size: 0.8rem;
  font-weight: 600;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  background: rgba(34, 197, 94, 0.08);
  color: #bbf7d0;
}
.focus-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.focus-info {
  font-size: 0.75rem;
  color: #6b7280;
  text-align: center;
  margin-bottom: 4px;
  min-height: 1.1em;
}

/* Modal */
.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.9);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 50;
}
.modal {
  background: #020617;
  border-radius: 18px;
  border: 1px solid #1f2937;
  padding: 20px 18px 16px;
  width: 100%;
  max-width: 420px;
  box-shadow: 0 24px 70px rgba(0,0,0,0.8);
}
.modal h2 {
  font-size: 1.1rem;
  margin: 0 0 6px;
}
.modal p {
  font-size: 0.8rem;
  color: #9ca3af;
  margin: 0 0 12px;
}
label {
  font-size: 0.78rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #6b7280;
  display: block;
  margin-bottom: 4px;
}
input {
  width: 100%;
  margin-bottom: 12px;
  padding: 9px 11px;
  border-radius: 10px;
  border: 1px solid #374151;
  background: #020617;
  color: #e5e7eb;
  font-size: 0.9rem;
}
input:focus {
  outline: none;
  border-color: #22c55e;
  box-shadow: 0 0 0 1px #22c55e33;
}
.modal-actions {
  display: flex;
  gap: 10px;
  margin-top: 4px;
}
.modal-btn {
  flex: 1;
  border-radius: 999px;
  border: none;
  padding: 9px 12px;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
}
.modal-btn.cancel {
  background: #111827;
  color: #e5e7eb;
  border: 1px solid #374151;
}
.modal-btn.submit {
  background: #22c55e;
  color: #022c22;
}
.modal-status {
  font-size: 0.78rem;
  margin-top: 6px;
  min-height: 1.2em;
}
.modal-status.err { color: #f97373; }
.modal-status.ok { color: #4ade80; }

@media (min-height: 800px) {
  .app { gap: 20px; }
}
  </style>
</head>
<body>

<video id="ug-bg" muted playsinline
  style="
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: -1;
  ">
  <source src="untergrund-bg.mp4" type="video/mp4">
</video>

  <div class="app">
    <header>
      <div class="logo-text">UnterGrund</div>
      <button class="pill-btn" onclick="openSubmit()">
        ‚ûï Artist vorschlagen
      </button>
    </header>

    <div class="card">
      <div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;">
        <div class="card-title" id="card-title">UnterGrund Explorer</div>
        <button id="info-btn"
                style="background:none;border:none;padding:0;font-size:0.85rem;color:#9ca3af;cursor:pointer;">
          ‚ìò
        </button>
      </div>
      <p class="card-sub">
        Deutsche Artists entdecken, die noch unter dem Radar fliegen.
        Pushe deine Favoriten nach oben ‚Äì jeder Klick z√§hlt.
      </p>

      <div id="artist-name" class="artist-name">Lade Artist‚Ä¶</div>
      <div id="embed-wrapper" class="embed-wrapper"></div>

      <!-- Focus-Bereich -->
      <div class="focus-buttons">
        <button id="focus-play" class="focus-btn" onclick="handleFocusPlay()" disabled>
          üéµ Play on Spotify
        </button>
        <button id="focus-follow" class="focus-btn" onclick="handleFocusFollow()" disabled>
          üíö Follow
        </button>
      </div>

      <div id="focus-info" class="focus-info"></div>

      <!-- kompakter Fortschrittsbalken -->
      <div id="focus-progress" style="margin:2px 4px 4px;">
        <div style="display:flex;align-items:center;gap:4px;">
          <span style="font-size:0.7rem;line-height:1;">üéµ</span>
          <div style="flex:1;height:4px;border-radius:999px;background:#020617;overflow:hidden;">
            <div id="focus-progress-bar"
                 style="height:100%;width:0%;background:linear-gradient(90deg,#22c55e,#a855f7);transition:width 0.25s ease-out;">
            </div>
          </div>
          <span id="focus-progress-label" style="font-size:0.7rem;color:#9ca3af;min-width:2.4em;text-align:right;">0%</span>
        </div>
      </div>

            <div id="status-text" class="status-text"></div>

      <!-- Teilen-Button -->
      <button class="pill-btn"
              style="width:100%;justify-content:center;margin-top:4px;background:#0b1120;color:#e5e7eb;"
              onclick="shareCurrentArtist()">
        üì§ Diesen Artist aus dem UnterGrund pushen
      </button>

      <!-- STAGE: Button + Hinweis -->
      <button id="stage-button"
              class="pill-btn"
              style="width:100%;justify-content:center;margin-top:8px;display:none;background:#22c55e;color:#022c22;"
              onclick="openStageForCurrentArtist()">
        üöÄ Stage ansehen
      </button>
      <div id="stage-hint" class="focus-info" style="margin-top:2px;"></div>
      <!-- /STAGE -->

      <button class="pill-btn" style="width:100%;justify-content:center;margin-top:8px;" onclick="loadNextArtist()">
        üîÅ N√§chster Artist
      </button>

    </div>
  </div>
  
  <div id="submit-modal" class="modal-backdrop">
    <div class="modal">
      <h2>Artist vorschlagen</h2>
      <p>Trage einen deutschen Artist ein, den man entdecken sollte.</p>
      <p style="font-size:0.78rem;color:#9ca3af;margin-top:4px;">
        Du hilfst, echte Untergrund‚ÄëActs sichtbar zu machen.
      </p>

      <label for="artist-input">Artist‚ÄëName</label>
      <input id="artist-input" placeholder="z.B. Doktor Eule" />

      <label for="spotify-input">Spotify‚ÄëArtist‚ÄëURL</label>
      <input id="spotify-input" placeholder="https://open.spotify.com/artist/‚Ä¶" />

      <div class="modal-actions">
        <button class="modal-btn cancel" onclick="closeSubmit()">Abbrechen</button>
        <button class="modal-btn submit" onclick="submitArtist()">Speichern</button>
      </div>

      <div id="submit-status" class="modal-status"></div>
    </div>
  </div>

  <div id="legal-modal-backdrop" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(15,23,42,0.9);z-index:80;">
    <div id="legal-modal" style="width:100%;max-width:480px;max-height:80vh;overflow-y:auto;background:#020617;border-radius:18px;border:1f2937;padding:18px 16px 14px;box-shadow:0 24px 70px rgba(0,0,0,0.85);font-size:0.78rem;color:#e5e7eb;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h2 id="legal-modal-title" style="font-size:0.9rem;margin:0;">Rechtliches</h2>
        <button onclick="closeLegal()" style="background:none;border:none;color:#9ca3af;font-size:1rem;cursor:pointer;">&times;</button>
      </div>
      <div id="legal-modal-content" style="color:#9ca3af;line-height:1.4;"></div>
    </div>
  </div>

  <!-- Info-Modal f√ºr Focus-Score -->
  <div id="info-modal-backdrop" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(15,23,42,0.9);z-index:70;">
    <div style="width:100%;max-width:420px;background:#020617;border-radius:18px;border:1px solid #1f2937;padding:18px 16px 14px;box-shadow:0 24px 70px rgba(0,0,0,0.85);font-size:0.8rem;color:#e5e7eb;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <h2 style="font-size:0.9rem;margin:0;">Was ist der Focus‚ÄëScore?</h2>
        <button onclick="closeInfoModal()" style="background:none;border:none;color:#9ca3af;font-size:1rem;cursor:pointer;">&times;</button>
      </div>
      <p style="color:#9ca3af;line-height:1.45;margin:0 0 8px;">
        Jeder Klick auf ‚ÄûPlay on Spotify‚Äú oder ‚ÄûFollow‚Äú gibt diesem Artist Focus‚ÄëPunkte
        (maximal 7 pro Browser). Dein Support entscheidet, wer aus dem UnterGrund hochkommt.
      </p>
      <p style="color:#9ca3af;line-height:1.45;margin:0 0 8px;">
        Der gr√ºne Focus‚ÄëBalken zeigt, wie weit ein Artist ist ‚Äì von 0&nbsp;% bis 100&nbsp;%.
        Je h√∂her der Score, desto heftiger reagiert der UnterGrund im Hintergrund‚ÄëVideo.
      </p>
      <p style="color:#9ca3af;line-height:1.45;margin:0;">
        Erreicht ein Artist 100&nbsp;%, bekommt er die Stage: wir nehmen Kontakt auf und
        helfen ihm, sein Profil weiter auszubauen.
      </p>
    </div>
  </div>

  <footer>
    <button onclick="openLegal('impressum')" style="background:none;border:none;color:#9ca3af;text-decoration:underline;cursor:pointer;margin-right:12px;">
      Impressum
    </button>
    <button onclick="openLegal('datenschutz')" style="background:none;border:none;color:#9ca3af;text-decoration:underline;cursor:pointer;">
      Datenschutzhinweise
    </button>
  </footer>
  
  <script>
    const SUPABASE_URL = "https://tyflhzwrwzfakwedipig.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_OkJhaPak_fd0nNg1vxRLPQ_gOiaI6Tb";
    const ARTISTS_TABLE = "artists";

    const MAX_PLAY_POINTS = 3;
    const MAX_JUMP_POINTS = 3;
    const MAX_FOLLOW_POINTS = 1;

    const MAX_FOCUS_SCORE = 1000;
    const VIDEO_DURATION = 15;

    let allArtists = [];
    let seenArtistIds = new Set();
    let loading = false;
    let currentArtist = null;

    let cheatTapCount = 0;
    let lastCheatTapTime = 0;
    let cheatUsedForArtist = null;

    let bgVideoPlayedForMax = false;

    function updateFocusBackground() {
  const video = document.getElementById("ug-bg");
  if (!video || !currentArtist) return;

  const score = currentArtist.focus_score || 0;
  const clamped = Math.max(0, Math.min(MAX_FOCUS_SCORE, score));
  const targetTime = (clamped / MAX_FOCUS_SCORE) * VIDEO_DURATION;

  const setTimeAndMaybePlay = () => {
    video.currentTime = targetTime;

    if (score < MAX_FOCUS_SCORE) {
      video.pause();
    }
  };

  if (isNaN(video.duration) || video.duration === 0) {
    video.addEventListener("canplay", setTimeAndMaybePlay, { once: true });
  } else {
    setTimeAndMaybePlay();
  }
    }

      if (isNaN(video.duration) || video.duration === 0) {
        video.addEventListener("canplay", setTimeAndMaybePlay, { once: true });
      } else {
        setTimeAndMaybePlay();
      }
    }

    function getClientId() {
      const KEY = "ug_client_id";
      let id = localStorage.getItem(KEY);
      if (!id) {
        id = "cli_" + Math.random().toString(36).slice(2) + Date.now().toString(36);
        localStorage.setItem(KEY, id);
      }
      return id;
    }

    function normalizeSpotifyArtistUrl(url) {
      if (!url) return null;
      let clean = url.split("?")[0].trim();
      clean = clean.replace("open.spotify.com/intl-de/", "open.spotify.com/");
      if (clean.endsWith("/")) clean = clean.slice(0, -1);
      return clean;
    }

    function spotifyUrlToEmbed(url) {
      const clean = normalizeSpotifyArtistUrl(url);
      if (!clean) return null;
      if (!clean.includes("open.spotify.com/artist/")) return null;
      return clean.replace("open.spotify.com/artist/", "open.spotify.com/embed/artist/");
    }

    function isValidSpotifyArtistUrl(url) {
      if (!url) return false;
      const clean = normalizeSpotifyArtistUrl(url);
      return clean.startsWith("https://open.spotify.com/artist/");
    }

    async function getFocusRow(artistId) {
      const clientId = getClientId();
      const res = await fetch(
        `${SUPABASE_URL}/rest/v1/focus_events?artist_id=eq.${artistId}&client_id=eq.${encodeURIComponent(clientId)}&select=*`,
        {
          headers: {
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`
          }
        }
      );
      if (!res.ok) {
        console.error("focus_events GET Fehler:", await res.text());
        return null;
      }
      const rows = await res.json();
      return rows[0] || null;
    }

    async function ensureFocusRow(artistId) {
      let row = await getFocusRow(artistId);
      if (row) return row;

      const clientId = getClientId();
      const res = await fetch(`${SUPABASE_URL}/rest/v1/focus_events`, {
        method: "POST",
        headers: {
          "apikey": SUPABASE_ANON_KEY,
          "Authorization": `Bearer ${SUPABASE_ANON_KEY}`,
          "Content-Type": "application/json",
          "Prefer": "return=representation"
        },
        body: JSON.stringify({
          artist_id: artistId,
          client_id: clientId
        })
      });
      if (!res.ok) {
        console.error("focus_events INIT Fehler:", await res.text());
        return null;
      }
      const created = await res.json();
      return created[0];
    }

    async function addFocus(artist, type) {
      if (!artist) return { ok: false, reason: "no-artist" };

      let row = await ensureFocusRow(artist.id);
      if (!row) return { ok: false, reason: "no-row" };

      let update = {};
      if (type === "play") {
        if (row.play_count >= MAX_PLAY_POINTS) return { ok: false, reason: "limit-play" };
        update.play_count = row.play_count + 1;
      } else if (type === "jump") {
        if (row.jump_count >= MAX_JUMP_POINTS) return { ok: false, reason: "limit-jump" };
        update.jump_count = row.jump_count + 1;
      } else if (type === "follow") {
        if (row.follow_used) return { ok: false, reason: "limit-follow" };
        update.follow_used = true;
      } else {
        return { ok: false, reason: "unknown-type" };
      }

      const resEvent = await fetch(
        `${SUPABASE_URL}/rest/v1/focus_events?id=eq.${row.id}`,
        {
          method: "PATCH",
          headers: {
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`,
            "Content-Type": "application/json",
            "Prefer": "return=minimal"
          },
          body: JSON.stringify(update)
        }
      );
      if (!resEvent.ok) {
        console.error("focus_events UPDATE Fehler:", await resEvent.text());
        return { ok: false, reason: "event-update" };
      }

      const newScore = (artist.focus_score || 0) + 1;
      const resArtist = await fetch(
        `${SUPABASE_URL}/rest/v1/${ARTISTS_TABLE}?id=eq.${artist.id}`,
        {
          method: "PATCH",
          headers: {
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`,
            "Content-Type": "application/json",
            "Prefer": "return=minimal"
          },
          body: JSON.stringify({ focus_score: newScore })
        }
      );
      if (!resArtist.ok) {
        console.error("artists focus_score UPDATE Fehler:", await resArtist.text());
        return { ok: false, reason: "artist-update" };
      }

      artist.focus_score = newScore;
      if (artist === currentArtist) {
        updateFocusBackground();
      }

      return { ok: true, newScore };
    }

    async function triggerCheatBoost() {
      if (!currentArtist) return;
      if (cheatUsedForArtist === currentArtist.id) return;

      const row = await ensureFocusRow(currentArtist.id);
      if (!row) return;

      const normalPoints =
        (row.play_count || 0) +
        (row.jump_count || 0) +
        (row.follow_used ? 1 : 0);

      if (normalPoints !== 4) return;
      if ((row.jump_count || 0) >= MAX_JUMP_POINTS) return;

      const remainingJump = MAX_JUMP_POINTS - (row.jump_count || 0);
      const boost = remainingJump;

      const resEvent = await fetch(
        `${SUPABASE_URL}/rest/v1/focus_events?id=eq.${row.id}`,
        {
          method: "PATCH",
          headers: {
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`,
            "Content-Type": "application/json",
            "Prefer": "return=minimal"
          },
          body: JSON.stringify({ jump_count: (row.jump_count || 0) + boost })
        }
      );
      if (!resEvent.ok) {
        console.error("Cheat-Boost event Fehler:", await resEvent.text());
        return;
      }

      const newScore = (currentArtist.focus_score || 0) + boost;
      const resArtist = await fetch(
        `${SUPABASE_URL}/rest/v1/${ARTISTS_TABLE}?id=eq.${currentArtist.id}`,
        {
          method: "PATCH",
          headers: {
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`,
            "Content-Type": "application/json",
            "Prefer": "return=minimal"
          },
          body: JSON.stringify({ focus_score: newScore })
        }
      );
      if (!resArtist.ok) {
        console.error("Cheat-Boost artist Fehler:", await resArtist.text());
        return;
      }

      currentArtist.focus_score = newScore;
      cheatUsedForArtist = currentArtist.id;

      updateFocusBackground();
      alert(`UnterGrund‚ÄëBoost! +${boost} Focus f√ºr ${currentArtist.name || "den Artist"}.`);

      await updateFocusUI();
    }

    // STAGE: √∂ffentlicher Stage-Link
    function openStageForCurrentArtist() {
      if (!currentArtist) return;
      window.location.href = `Stage.html?artist_id=${encodeURIComponent(currentArtist.id)}`;
    }

    
     async function updateFocusUI() {
      const infoEl = document.getElementById("focus-info");
      const btnPlay = document.getElementById("focus-play");
      const btnFollow = document.getElementById("focus-follow");
      const bar = document.getElementById("focus-progress-bar");
      const label = document.getElementById("focus-progress-label");
      const stageBtn = document.getElementById("stage-button");   // STAGE
      const stageHint = document.getElementById("stage-hint");    // STAGE

      if (!currentArtist) {
        btnPlay.disabled = true;
        btnFollow.disabled = true;
        infoEl.textContent = "";
        if (bar && label) {
          bar.style.width = "0%";
          label.textContent = "0%";
        }
        if (stageBtn) stageBtn.style.display = "none";            // STAGE
        if (stageHint) stageHint.textContent = "";                // STAGE
        return;
      }

      const row = await getFocusRow(currentArtist.id) || {
        play_count: 0,
        jump_count: 0,
        follow_used: false
      };

      const playLeft = Math.max(0, MAX_PLAY_POINTS - (row.play_count || 0));
      const jumpLeft = Math.max(0, MAX_JUMP_POINTS - (row.jump_count || 0));
      const followLeft = row.follow_used ? 0 : MAX_FOLLOW_POINTS;

      const totalLeft = playLeft + jumpLeft + followLeft;
      const maxTotal = MAX_PLAY_POINTS + MAX_JUMP_POINTS + MAX_FOLLOW_POINTS;

      btnPlay.disabled = playLeft <= 0;
      btnFollow.disabled = followLeft <= 0;

      const normalPoints =
        (row.play_count || 0) +
        (row.jump_count || 0) +
        (row.follow_used ? 1 : 0);

      const score = currentArtist.focus_score || 0;

      let pct = Math.round((score / MAX_FOCUS_SCORE) * 100);
      if (score < MAX_FOCUS_SCORE && pct >= 100) {
        pct = 99;
      }
      if (score >= MAX_FOCUS_SCORE) {
        pct = 100;
      }

      if (score >= MAX_FOCUS_SCORE) {
        infoEl.textContent =
          `${currentArtist.name || "Dieser Artist"} hat die Stage erreicht ‚Äì wir nehmen Kontakt auf.`;
      } else if (normalPoints === 4) {
        infoEl.textContent =
          `Du hast ${currentArtist.name || "diesen Artist"} voll gepusht. ` +
          "Manche entdecken hier noch einen versteckten UnterGrund‚ÄëBoost.";
      } else if (totalLeft > 0) {
        infoEl.textContent =
          `Jeder Push erh√∂ht den Focus‚ÄëScore (0‚Äì100‚ÄØ%). ` +
          `Du kannst ${currentArtist.name || "diesen Artist"} noch ${totalLeft}√ó pushen ` +
          `(max. ${maxTotal} Punkte pro Browser).`;
      } else {
        infoEl.textContent =
          `Du hast ${currentArtist.name || "diesen Artist"} maximal gepusht. Danke!`;
      }

      if (bar && label) {
        bar.style.width = pct + "%";
        label.textContent = pct + "%";
      }

      // STAGE: Button und Hinweis steuern
      const reachedStage = score >= MAX_FOCUS_SCORE;
      if (stageBtn) {
        stageBtn.style.display = reachedStage ? "block" : "none";
      }
      if (stageHint) {
        if (reachedStage) {
          stageHint.textContent =
            "Dieser Artist hat die Stage erreicht. Sobald er seine Stage f√ºllt, kannst du hier sehen, was er der Community zur√ºckgibt.";
        } else {
          stageHint.textContent = "";
        }
      }
    }


    async function handleFocusPlay() {
  if (!currentArtist) return;
  
  // Video jetzt starten wenn 100% erreicht wird
  const willBe100 = (currentArtist.focus_score || 0) + 1 >= MAX_FOCUS_SCORE;
  if (willBe100 && !bgVideoPlayedForMax) {
    document.getElementById("ug-bg")?.play().catch(() => {});
    bgVideoPlayedForMax = true;
  }
  
  const res = await addFocus(currentArtist, "play");

  if (res.ok) {
    alert(`Focus +1 ‚Äì du hast ${currentArtist.name || "den Artist"} gepusht.`);
  } else if (res.reason && res.reason.startsWith("limit")) {
    alert("Limit erreicht ‚Äì du kannst diesen Artist nicht weiter pushen.");
  }
  await updateFocusUI();

  const url = normalizeSpotifyArtistUrl(currentArtist.spotify_url);
  if (url) window.open(url, "_blank");
    }

    async function handleFocusFollow() {
  if (!currentArtist) return;
  
  // Video jetzt starten wenn 100% erreicht wird
  const willBe100 = (currentArtist.focus_score || 0) + 1 >= MAX_FOCUS_SCORE;
  if (willBe100 && !bgVideoPlayedForMax) {
    document.getElementById("ug-bg")?.play().catch(() => {});
    bgVideoPlayedForMax = true;
  }
  
  const res = await addFocus(currentArtist, "follow");

  if (res.ok) {
    alert(`Focus +1 ‚Äì du folgst ${currentArtist.name || "dem Artist"} (auf Spotify √∂ffnen).`);
  } else if (res.reason && res.reason.startsWith("limit")) {
    alert("Follow-Limit erreicht ‚Äì du kannst diesen Artist nur einmal follow-pushen.");
  }
  await updateFocusUI();

  const url = normalizeSpotifyArtistUrl(currentArtist.spotify_url);
  if (url) window.open(url, "_blank");
    }

    async function shareCurrentArtist() {
      if (!currentArtist) return;

      const url = window.location.origin + window.location.pathname + "?artist=" + encodeURIComponent(currentArtist.id);
      const text = `Diesen Artist aus dem UnterGrund pushen: ${currentArtist.name || "Unbekannter Artist"}`;

      try {
        if (navigator.share) {
          await navigator.share({
            title: "UnterGrund Explorer",
            text,
            url
          });
        } else if (navigator.clipboard) {
          await navigator.clipboard.writeText(`${text} ${url}`);
          alert("Link zum UnterGrund‚ÄëArtist kopiert.");
        } else {
          const fallback = prompt("Link kopieren:", `${text} ${url}`);
          if (!fallback) return;
        }
      } catch (err) {
        console.error("Share abgebrochen/Fehler:", err);
      }
    }

    async function loadAllArtists() {
      const res = await fetch(
        `${SUPABASE_URL}/rest/v1/${ARTISTS_TABLE}?select=*`,
        {
          headers: {
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`
          }
        }
      );

      if (!res.ok) {
        const txt = await res.text();
        console.error("Artists Load Fehler:", res.status, txt);
        throw new Error("Supabase Load Fehler: " + res.status);
      }

      allArtists = await res.json();
    }

    function pickRandomUnseenArtist() {
      const unseen = allArtists.filter(a => !seenArtistIds.has(a.id));
      if (unseen.length === 0) return null;
      const idx = Math.floor(Math.random() * unseen.length);
      return unseen[idx];
    }

    async function loadArtistById(id) {
      const nameEl = document.getElementById("artist-name");
      const statusEl = document.getElementById("status-text");
      const embedWrapper = document.getElementById("embed-wrapper");

      try {
        const res = await fetch(
          `${SUPABASE_URL}/rest/v1/${ARTISTS_TABLE}?id=eq.${encodeURIComponent(id)}&select=*`,
          {
            headers: {
              "apikey": SUPABASE_ANON_KEY,
              "Authorization": `Bearer ${SUPABASE_ANON_KEY}`
            }
          }
        );
        if (!res.ok) {
          console.error("loadArtistById Fehler:", await res.text());
          return false;
        }
        const rows = await res.json();
        if (!rows || rows.length === 0) return false;

        const artist = rows[0];
        currentArtist = artist;
        bgVideoPlayedForMax = false;
        seenArtistIds.add(artist.id);

        updateFocusBackground();

        nameEl.textContent = artist.name || "";
        statusEl.textContent = "Pushe diesen Artist mit den Buttons ‚Äì jeder Sprung zu Spotify erh√∂ht seinen Focus.";

        const embedUrl = spotifyUrlToEmbed(artist.spotify_url);
        if (embedUrl) {
          embedWrapper.innerHTML = `<iframe src="${embedUrl}" allow="encrypted-media"></iframe>`;
        } else {
          embedWrapper.innerHTML = `<div style="font-size:0.85rem;color:#f97373;padding:12px;">
            Kein g√ºltiger Spotify‚ÄëLink gespeichert.
          </div>`;
        }

        await updateFocusUI();
        return true;
      } catch (err) {
        console.error("loadArtistById Fehler:", err);
        return false;
      }
    }

        async function loadNextArtist() {
      if (loading) return;
      loading = true;

      const nameEl = document.getElementById("artist-name");
      const statusEl = document.getElementById("status-text");
      const embedWrapper = document.getElementById("embed-wrapper");

      const btnPlay = document.getElementById("focus-play");
      const btnFollow = document.getElementById("focus-follow");
      const infoEl = document.getElementById("focus-info");
      const bar = document.getElementById("focus-progress-bar");
      const label = document.getElementById("focus-progress-label");
      const stageBtn = document.getElementById("stage-button"); // STAGE
      const stageHint = document.getElementById("stage-hint"); // STAGE

      nameEl.textContent = "Suche n√§chsten Artist‚Ä¶";
      statusEl.textContent = "";
      embedWrapper.innerHTML = "";
      currentArtist = null;

      btnPlay.disabled = true;
      btnFollow.disabled = true;
      infoEl.textContent = "";
      if (bar && label) {
        bar.style.width = "0%";
        label.textContent = "0%";
      }
      if (stageBtn) stageBtn.style.display = "none";   // STAGE
      if (stageHint) stageHint.textContent = "";       // STAGE

      cheatTapCount = 0;
      lastCheatTapTime = 0;
      cheatUsedForArtist = null;

      try {
        if (!allArtists || allArtists.length === 0) {
          await loadAllArtists();
        }

        let artist = pickRandomUnseenArtist();

        if (!artist) {
          await loadAllArtists();
          seenArtistIds = new Set();
          artist = pickRandomUnseenArtist();
        }

        if (!artist) {
          nameEl.textContent = "Noch keine Artists gespeichert.";
          return;
        }

        seenArtistIds.add(artist.id);
        currentArtist = artist;
        bgVideoPlayedForMax = false;

        updateFocusBackground();

        nameEl.textContent = artist.name || "";
        statusEl.textContent = "Pushe diesen Artist mit den Buttons ‚Äì jeder Sprung zu Spotify erh√∂ht seinen Focus.";

        const embedUrl = spotifyUrlToEmbed(artist.spotify_url);
        if (embedUrl) {
          embedWrapper.innerHTML = `<iframe src="${embedUrl}" allow="encrypted-media"></iframe>`;
        } else {
          embedWrapper.innerHTML = `<div style="font-size:0.85rem;color:#f97373;padding:12px;">
            Kein g√ºltiger Spotify‚ÄëLink gespeichert.
          </div>`;
        }

        await updateFocusUI();

      } catch (err) {
        console.error("loadNextArtist Fehler:", err);
        nameEl.textContent = "Fehler beim Laden.";
        statusEl.textContent = "Bitte sp√§ter erneut versuchen.";
      } finally {
        loading = false;
      }
    }

    function openSubmit() {
      document.getElementById("submit-modal").style.display = "flex";
      document.getElementById("submit-status").textContent = "";
      document.getElementById("artist-input").focus();
    }

    function closeSubmit() {
      document.getElementById("submit-modal").style.display = "none";
    }

    function openInfoModal() {
      const backdrop = document.getElementById("info-modal-backdrop");
      if (backdrop) backdrop.style.display = "flex";
    }

    function closeInfoModal() {
      const backdrop = document.getElementById("info-modal-backdrop");
      if (backdrop) backdrop.style.display = "none";
    }

    async function submitArtist() {
      const nameInput = document.getElementById("artist-input");
      const spotifyInput = document.getElementById("spotify-input");
      const statusEl = document.getElementById("submit-status");

      const manualName = nameInput.value.trim();
      const rawUrl = spotifyInput.value.trim();

      if (!manualName) {
        statusEl.textContent = "Bitte den Artist‚ÄëNamen eingeben.";
        statusEl.className = "modal-status err";
        return;
      }

      if (!rawUrl) {
        statusEl.textContent = "Bitte eine Spotify‚ÄëArtist‚ÄëURL eingeben.";
        statusEl.className = "modal-status err";
        return;
      }

      if (!isValidSpotifyArtistUrl(rawUrl)) {
        statusEl.textContent = "Bitte einen g√ºltigen Spotify‚ÄëArtist‚ÄëLink eingeben (https://open.spotify.com/artist/‚Ä¶).";
        statusEl.className = "modal-status err";
        return;
      }

      const cleanUrl = normalizeSpotifyArtistUrl(rawUrl);

      statusEl.textContent = "Pr√ºfe, ob der Artist schon existiert‚Ä¶";
      statusEl.className = "modal-status";

      try {
        const checkRes = await fetch(
          `${SUPABASE_URL}/rest/v1/${ARTISTS_TABLE}?spotify_url=eq.${encodeURIComponent(cleanUrl)}&select=id`,
          {
            headers: {
              "apikey": SUPABASE_ANON_KEY,
              "Authorization": `Bearer ${SUPABASE_ANON_KEY}`
            }
          }
        );

        if (!checkRes.ok) {
          const txt = await checkRes.text();
          console.error("Check Fehler:", checkRes.status, txt);
          throw new Error("Supabase Check Fehler: " + checkRes.status);
        }

        const existing = await checkRes.json();

        if (existing.length > 0) {
          statusEl.textContent = "Dieser Artist ist schon im UnterGrund gespeichert.";
          statusEl.className = "modal-status err";
          return;
        }

        statusEl.textContent = "Speichere Artist‚Ä¶";

        const res = await fetch(`${SUPABASE_URL}/rest/v1/${ARTISTS_TABLE}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "apikey": SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_ANON_KEY}`,
            "Prefer": "return=minimal"
          },
          body: JSON.stringify({
            name: manualName,
            spotify_url: cleanUrl
          })
        });

        if (!res.ok) {
          const txt = await res.text();
          console.error("Insert Fehler:", res.status, txt);
          if (res.status === 409) {
            statusEl.textContent = "Dieser Artist existiert bereits (DB‚ÄëConstraint).";
            statusEl.className = "modal-status err";
            return;
          }
          throw new Error("Supabase Insert Fehler: " + res.status);
        }

        nameInput.value = "";
        spotifyInput.value = "";
        statusEl.textContent = "‚úÖ Artist gespeichert! Er erscheint im Explorer.";
        statusEl.className = "modal-status ok";

        await loadAllArtists();
      } catch (err) {
        console.error("submitArtist Fehler:", err);
        statusEl.textContent = "‚ùå Fehler: " + (err?.message || "Unbekannter Fehler");
        statusEl.className = "modal-status err";
      }
    }

    const LEGAL_TEXT = {
      impressum: `
        <p>Verantwortlich f√ºr den Inhalt dieser Seite:</p>
        <p>
          [Dein Vor- und Nachname]<br>
          [Stra√üe, Hausnummer]<br>
          [PLZ, Ort]<br>
          Deutschland
        </p>
        <p>E-Mail: [deine@email.de]</p>
      `,
      datenschutz: `
        <p>Diese Seite wird √ºber GitHub Pages und Supabase bereitgestellt.
        Beim Aufruf werden technisch notwendige Daten (z.B. IP-Adresse,
        Datum und Uhrzeit des Abrufs, aufgerufene URL, User-Agent) verarbeitet.</p>

        <p>Beim Vorschlagen von Artists werden die eingegebenen Daten
        (Artist-Name, Spotify-URL) in einer Supabase-Datenbank gespeichert und
        im ‚ÄûUnterGrund Explorer" angezeigt. Auf Anfrage per E-Mail werden Eintr√§ge
        gel√∂scht und von weiteren Vorschl√§gen ausgeschlossen.</p>

        <p>Auf dieser Seite sind Spotify-Player eingebunden. Anbieter ist Spotify AB.
        Beim Laden eines Spotify-Embeds kann Spotify personenbezogene Daten
        verarbeiten. Weitere Informationen enth√§lt die Datenschutzerkl√§rung von Spotify.</p>

        <p>Diese Seite speichert eine anonyme Client-ID im localStorage, um zu begrenzen,
        wie oft ein Browser einen Artist pushen kann.</p>
      `
    };

    function openLegal(type) {
      const backdrop = document.getElementById("legal-modal-backdrop");
      const titleEl = document.getElementById("legal-modal-title");
      const contentEl = document.getElementById("legal-modal-content");

      if (type === "impressum") {
        titleEl.textContent = "Impressum";
        contentEl.innerHTML = LEGAL_TEXT.impressum;
      } else {
        titleEl.textContent = "Datenschutzhinweise";
        contentEl.innerHTML = LEGAL_TEXT.datenschutz;
      }

      backdrop.style.display = "flex";
    }

    function closeLegal() {
      document.getElementById("legal-modal-backdrop").style.display = "none";
    }

    function setupCheatListener() {
      const titleEl = document.getElementById("card-title");
      if (titleEl) {
        titleEl.addEventListener("click", () => {
          const now = Date.now();
          if (now - lastCheatTapTime > 1500) {
            cheatTapCount = 0;
          }
          lastCheatTapTime = now;
          cheatTapCount += 1;

          if (cheatTapCount >= 5) {
            cheatTapCount = 0;
            triggerCheatBoost();
          }
        });
      }

      const infoBtn = document.getElementById("info-btn");
      if (infoBtn) {
        infoBtn.addEventListener("click", openInfoModal);
      }
    }

    async function initApp() {
      setupCheatListener();

      const params = new URLSearchParams(window.location.search);
      const artistIdFromUrl = params.get("artist");

      if (artistIdFromUrl) {
        const ok = await loadArtistById(artistIdFromUrl);
        if (!ok) {
          await loadNextArtist();
        }
      } else {
        await loadNextArtist();
      }
    }
    
    window.addEventListener("load", () => {
      initApp();
    });
  </script>
</body>
</html>
